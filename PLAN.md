# План реализации проекта ChatList

## Этап 1: Подготовка проекта и структуры

### 1.1 Инициализация проекта
- [ ] Создать структуру папок проекта
- [ ] Настроить виртуальное окружение (опционально)
- [ ] Обновить `requirements.txt` с необходимыми зависимостями:
  - PyQt5 (уже есть)
  - requests или httpx
  - python-dotenv (для работы с .env файлами)
  - sqlite3 (встроенный в Python)

### 1.2 Создание структуры модулей
- [ ] Создать модуль `db.py` - работа с базой данных
- [ ] Создать модуль `models.py` - логика работы с моделями
- [ ] Создать модуль `network.py` - отправка HTTP-запросов к API
- [ ] Обновить `main.py` - основной GUI интерфейс
- [ ] Создать `config.py` - конфигурация и загрузка переменных окружения

### 1.3 Создание файлов конфигурации
- [ ] Создать `.env.example` - пример файла с переменными окружения
- [ ] Создать `.env` - файл для хранения API-ключей (добавить в .gitignore)

---

## Этап 2: Реализация базы данных

### 2.1 Создание модуля db.py
- [ ] Реализовать функцию инициализации БД (`init_database()`)
- [ ] Создать таблицу `prompts` (id, date, prompt, tags)
- [ ] Создать таблицу `models` (id, name, api_url, api_key_env, is_active)
- [ ] Создать таблицу `results` (id, prompt_id, model_id, response_text, saved_date)
- [ ] Создать таблицу `settings` (id, key, value)
- [ ] Реализовать CRUD операции для каждой таблицы:
  - `create_prompt()`, `get_prompts()`, `update_prompt()`, `delete_prompt()`
  - `create_model()`, `get_models()`, `get_active_models()`, `update_model()`, `delete_model()`
  - `save_result()`, `get_results()`, `delete_result()`
  - `get_setting()`, `set_setting()`

### 2.2 Тестирование БД
- [ ] Протестировать создание таблиц
- [ ] Протестировать все CRUD операции
- [ ] Проверить целостность данных и связи между таблицами

---

## Этап 3: Реализация работы с моделями

### 3.1 Создание модуля models.py
- [ ] Создать класс `Model` для представления нейросети
- [ ] Реализовать методы для работы с моделями:
  - Получение списка активных моделей из БД
  - Валидация настроек модели
  - Поддержка разных типов API (OpenAI, DeepSeek, Groq и т.д.)

### 3.2 Создание модуля network.py
- [ ] Реализовать базовый класс `APIProvider` или использовать функции
- [ ] Создать функции для отправки запросов к разным API:
  - `send_to_openai()` - для OpenAI API
  - `send_to_deepseek()` - для DeepSeek API
  - `send_to_groq()` - для Groq API
  - `send_request()` - универсальная функция-роутер
- [ ] Реализовать обработку ошибок и таймаутов
- [ ] Добавить логирование запросов (опционально)

### 3.3 Интеграция с .env
- [ ] Создать `config.py` для загрузки переменных окружения
- [ ] Реализовать функцию получения API-ключей по имени переменной из БД

---

## Этап 4: Реализация GUI интерфейса

### 4.1 Основной интерфейс (main.py)
- [ ] Создать главное окно приложения
- [ ] Реализовать область ввода промта:
  - Текстовое поле для ввода нового промта
  - Выпадающий список для выбора сохраненного промта
  - Кнопка "Отправить"
- [ ] Реализовать область выбора моделей:
  - Список чекбоксов для выбора активных моделей
  - Кнопка "Выбрать все" / "Снять все"
- [ ] Реализовать таблицу результатов:
  - Колонки: "Модель", "Ответ", "Выбрано" (чекбокс)
  - Возможность прокрутки для длинных ответов
  - Автоматическое обновление при получении ответов
- [ ] Реализовать кнопку "Сохранить" для сохранения выбранных результатов

### 4.2 Дополнительные окна и функции
- [ ] Создать окно управления моделями:
  - Добавление/редактирование/удаление моделей
  - Настройка API URL и имени переменной для ключа
  - Активация/деактивация моделей
- [ ] Создать окно управления промтами:
  - Просмотр сохраненных промтов
  - Редактирование промтов и тегов
  - Удаление промтов
- [ ] Создать окно просмотра сохраненных результатов:
  - Таблица с сохраненными результатами
  - Поиск и фильтрация
  - Экспорт в Markdown/JSON (опционально)

---

## Этап 5: Интеграция компонентов

### 5.1 Связывание GUI с бизнес-логикой
- [ ] Подключить модуль `db.py` к интерфейсу
- [ ] Реализовать отправку запросов при нажатии "Отправить"
- [ ] Реализовать асинхронную отправку запросов (или с прогресс-баром)
- [ ] Реализовать отображение результатов в таблице
- [ ] Реализовать сохранение выбранных результатов в БД

### 5.2 Обработка событий
- [ ] Обработка нажатия кнопки "Отправить"
- [ ] Обработка выбора промта из списка
- [ ] Обработка изменения чекбоксов в таблице результатов
- [ ] Обработка нажатия кнопки "Сохранить"
- [ ] Обработка очистки временной таблицы при новом запросе

### 5.3 Улучшение UX
- [ ] Добавить индикатор загрузки при отправке запросов
- [ ] Добавить обработку ошибок с понятными сообщениями
- [ ] Реализовать автосохранение промта при вводе (опционально)

---

## Этап 6: Дополнительные функции

### 6.1 Поиск и сортировка
- [ ] Реализовать поиск в таблице промтов
- [ ] Реализовать поиск в таблице результатов
- [ ] Добавить сортировку по колонкам во всех таблицах

### 6.2 Экспорт данных
- [ ] Реализовать экспорт результатов в Markdown
- [ ] Реализовать экспорт результатов в JSON
- [ ] Добавить кнопки экспорта в интерфейс

### 6.3 Логирование
- [ ] Настроить логирование запросов к API
- [ ] Сохранять логи в файл или БД
- [ ] Добавить просмотр логов в интерфейсе (опционально)

### 6.4 AI-ассистент для улучшения промтов
- [x] Создать модуль `prompt_improver.py` для работы с улучшением промтов
- [x] Реализовать функцию `improve_prompt()`:
  - Принимает исходный промт и модель для улучшения
  - Формирует специальный промт для улучшения (системный промт)
  - Отправляет запрос через существующий OpenRouter-клиент
  - Парсит ответ и извлекает улучшенные варианты
- [x] Реализовать функцию `get_prompt_variants()`:
  - Генерация улучшенной версии промта
  - Генерация 2-3 вариантов переформулировки
  - Адаптация промта под разные типы моделей (код, анализ, креатив)
- [x] Создать диалог `PromptImproverDialog`:
  - Отображение исходного промта
  - Отображение улучшенного варианта
  - Отображение альтернативных вариантов (вкладки или список)
  - Кнопки "Подставить в поле ввода" для каждого варианта
  - Кнопка "Закрыть"
- [x] Добавить кнопку "Улучшить промт" в область ввода промта:
  - Разместить рядом с полем ввода промта
  - Активируется только если введен текст промта
  - При нажатии открывает диалог улучшения
- [x] Реализовать выбор модели для улучшения:
  - Выпадающий список с активными моделями (по умолчанию OpenRouter)
  - Возможность выбрать любую активную модель
- [x] Интеграция с основным интерфейсом:
  - При нажатии "Подставить в поле ввода" - текст вставляется в поле промта
  - Сохранение истории улучшений (опционально)
- [x] Обработка ошибок:
  - Обработка ошибок API при улучшении
  - Понятные сообщения об ошибках пользователю
  - Fallback на исходный промт при ошибке

---

## Этап 7: Тестирование и отладка

### 7.1 Функциональное тестирование
- [ ] Протестировать создание и сохранение промтов
- [ ] Протестировать добавление и настройку моделей
- [ ] Протестировать отправку запросов к разным API
- [ ] Протестировать сохранение результатов
- [ ] Протестировать поиск и сортировку

### 7.2 Тестирование граничных случаев
- [ ] Тестирование с неверными API-ключами
- [ ] Тестирование при отсутствии интернета
- [ ] Тестирование с очень длинными промтами
- [ ] Тестирование с большим количеством моделей

### 7.3 Оптимизация
- [ ] Оптимизировать запросы к БД
- [ ] Оптимизировать работу с GUI (если есть задержки)
- [ ] Проверить использование памяти

---

## Этап 8: Финальная подготовка

### 8.1 Документация
- [ ] Обновить README.md с инструкциями по использованию
- [ ] Добавить примеры конфигурации .env
- [ ] Добавить описание всех функций программы

### 8.2 Сборка исполняемого файла
- [ ] Обновить `build.ps1` для включения всех модулей
- [ ] Протестировать сборку .exe файла
- [ ] Проверить работу .exe файла на чистой системе

### 8.3 Очистка
- [ ] Удалить временные файлы
- [ ] Проверить .gitignore
- [ ] Подготовить финальную версию для релиза

---

## Порядок выполнения (приоритет)

1. **Этап 1** - Подготовка (основа для всего проекта)
2. **Этап 2** - База данных (нужна для хранения данных)
3. **Этап 3** - Модели и сеть (логика работы с API)
4. **Этап 4** - GUI (интерфейс пользователя)
5. **Этап 5** - Интеграция (связывание всех компонентов)
6. **Этап 6** - Дополнительные функции (по желанию)
7. **Этап 7** - Тестирование (проверка работоспособности)
8. **Этап 8** - Финальная подготовка (релиз)
